/* eslint-disable @typescript-eslint/no-explicit-any */
import _ from 'lodash';
import { FindOptionsWhere, FindManyOptions, getConnection, getRepository, Repository, SelectQueryBuilder, In, ObjectLiteral } from 'typeorm';
import { QueryDeepPartialEntity } from 'typeorm/query-builder/QueryPartialEntity';
import { transArray } from '../utils/transformer';
import { id } from './IdGenerator';
import { PaginationIn, PaginationOut, setSorting, skipAndTake } from './Pagination';
import { ClassType } from './types';

export type TransformOptions = {
  voClass: ClassType;
  groups?: string[];
};

export type QueryCallback<T extends ObjectLiteral> = (qb: SelectQueryBuilder<T>) => void;

export type QueryOptions<T extends ObjectLiteral> = {
  searchColumns?: (keyof T)[];
  noDelRecord?: boolean;
  filterGenerator?: (column: string, filters: Record<string, string>, clauses: string[], conditions: Record<string, string>) => boolean;
  beforeExecute?: QueryCallback<T>;
} & TransformOptions;

export class UniversalService<Entity extends ObjectLiteral, ID = any> {
  public static DEL_VAL: { DELETED: any; NORMAL: any } = { DELETED: true, NORMAL: false };

  private _repo: Repository<Entity>;

  private properties: string[] = [];

  constructor(public readonly entity: ClassType<Entity>) {
    this._repo = getRepository(entity) as Repository<Entity>;
    this.properties = getConnection()
      .getMetadata(entity)
      .ownColumns.map((c) => c.propertyName);
  }

  get repo() {
    return this._repo;
  }

  hasProperty(propertyName: string): boolean {
    return _.includes(this.properties, propertyName);
  }

  async getAll<T = Entity>(voClass?: ClassType<T>, groups?: string[]) {
    const records = await this.repo.find(this.hasProperty('isDel') ? { where: { isDel: false } as any } : undefined);
    if (voClass) {
      return transArray(voClass, records, groups);
    } else {
      return records as any as T[];
    }
  }

  async create(entity: QueryDeepPartialEntity<Entity> | QueryDeepPartialEntity<Entity>[], autoGenerateData = true, idLength = 10) {
    if (autoGenerateData) {
      const autoGen = (entity: any) => {
        if (this.hasProperty('id') && _.isEmpty(entity['id'])) {
          entity['id'] = id(idLength);
        }
        if (this.hasProperty('isDel') && _.isNil(entity['isDel'])) {
          entity['isDel'] = false;
        }
        if (this.hasProperty('createdAt') && _.isNil(entity['createdAt'])) {
          entity['createdAt'] = new Date();
        }
      };
      if (Array.isArray(entity)) {
        entity.forEach(autoGen);
      } else {
        autoGen(entity);
      }
    }
    return this._repo.insert(_.omitBy(entity as any, _.isNil));
  }

  async readByIds(ids: ID[], options?: FindManyOptions<Entity>) {
    const whereCondition = { id: In(ids) } as any;
    if (this.hasProperty('isDel')) {
      return this._repo.find({
        where: { ...whereCondition, isDel: false },
        ...options,
      });
    } else {
      return this._repo.find({
        where: whereCondition,
        ...options,
      });
    }
  }

  async readById(id: ID, options?: FindManyOptions<Entity>) {
    const whereCondition = { id } as any;
    if (this.hasProperty('isDel')) {
      return this._repo.findOne({
        where: { ...whereCondition, isDel: false },
        ...options,
      });
    } else {
      return this._repo.findOne({
        where: whereCondition,
        ...options,
      });
    }
  }

  async update(criteria: string | number | Date | string[] | number[] | Date[] | FindOptionsWhere<Entity>, partialEntity: QueryDeepPartialEntity<Entity>, autoGenerateData = true) {
    if (autoGenerateData) {
      const autoGen = (entity: any) => {
        if (this.hasProperty('lastUpdate') && _.isNil(entity['lastUpdate'])) {
          entity['lastUpdate'] = new Date();
        }
      };
      autoGen(partialEntity);
    }
    let val = _.omitBy(partialEntity, _.isNil) as any;
    if (this.hasProperty('id')) {
      val = _.omit(val, 'id');
    }
    if (this.hasProperty('isDel')) {
      val = _.omit(val, 'isDel');
    }
    return this._repo.update(criteria, val);
  }

  async remove(criteria: string | number | Date | string[] | number[] | Date[] | FindOptionsWhere<Entity>) {
    if (this.hasProperty('isDel')) {
      return this._repo.update(criteria, { isDel: UniversalService.DEL_VAL.DELETED } as any);
    } else {
      return this._repo.delete(criteria);
    }
  }

  private getFilters(search: any) {
    const filters: Record<string, string> = {};
    Object.keys(search).forEach((key) => {
      const val = search[key];
      if (this.hasProperty(key) && !_.isNil(val)) {
        filters[key] = val;
      }
    });
    return filters;
  }

  async query<T extends PaginationIn>(search: T, options: QueryOptions<Entity>) {
    const qb = this._repo.createQueryBuilder('_tb');
    const clauses: string[] = [];
    const conditions: Record<string, string> = {};

    if (search.search && !_.isNil(options.searchColumns)) {
      const _cla: string[] = [];
      search.search.split(' ').forEach((cla, idx) => {
        options.searchColumns!.forEach((column) => {
          _cla.push(`_tb.${String(column)} like :${String(column)}${idx}`);
          conditions[`${String(column)}${idx}`] = `%${cla}%`;
        });
      });
      if (!_.isEmpty(_cla)) {
        clauses.push(_cla.join(' or '));
      }
    }

    const filters = this.getFilters(search);

    if (!_.isEmpty(filters)) {
      Object.keys(filters).forEach((column) => {
        const value = filters[column];
        if (!_.isNil(value) && this.hasProperty(column)) {
          const fn = () => {
            clauses.push(`_tb.${column} = :__${column}`);
            conditions[`__${column}`] = value;
          };
          if (options.filterGenerator) {
            if (!options.filterGenerator(column, filters, clauses, conditions)) {
              fn();
            }
          } else {
            fn();
          }
        }
      });
    }

    if ((options.noDelRecord ?? true) && this.hasProperty('isDel')) {
      clauses.push('_tb.isDel = 0');
    }

    const where = clauses.map((clause) => `(${clause})`).join(' and ');
    qb.where(where, conditions);

    if (options.beforeExecute) {
      options.beforeExecute(qb);
    }

    const count = await qb.getCount();
    const { skip, take } = skipAndTake(count, search);
    if (search.sort) {
      const column = search.sort.startsWith('!') ? search.sort.substr(1) : search.sort;
      if (this.hasProperty(column)) {
        setSorting(qb, '_tb', search.sort);
      }
    }

    const records = await qb.skip(skip).take(take).getMany();
    return new PaginationOut(count, search.pageSize, options.voClass, records, options.groups);
  }
}
